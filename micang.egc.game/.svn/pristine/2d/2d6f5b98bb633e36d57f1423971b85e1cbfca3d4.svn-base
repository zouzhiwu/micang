package com.game.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.commons.collections.CollectionUtils;
import org.quartz.JobKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.cb.msg.Message;
import com.cb.msg.MsgSender;
import com.cb.util.CBUtils;
import com.cb.util.ChannelUtil;
import com.common.constant.BoxConstant;
import com.common.constant.CircleConstant;
import com.common.constant.HeroConstant;
import com.common.constant.RoomConstant;
import com.common.constant.SubjectConstant;
import com.common.constant.TemplateConstant;
import com.common.entity.Account;
import com.common.entity.AccountScore;
import com.common.entity.Box;
import com.common.entity.Circle;
import com.common.entity.Hero;
import com.common.entity.KeyValue;
import com.common.entity.Location;
import com.common.entity.Role;
import com.common.entity.Room;
import com.common.entity.RoomInfo;
import com.common.entity.ServerAddress;
import com.common.entity.Skill;
import com.common.entity.Target;
import com.common.entity.TeamAccount;
import com.common.enumerate.AccountState;
import com.common.enumerate.RoomState;
import com.common.enumerate.TeamRole;
import com.common.helper.RandomHelper;
import com.common.helper.TimeHelper;
import com.common.template.CircleTemplate;
import com.common.template.RewardTemplate;
import com.common.template.RoleTemplate;
import com.common.template.TeamTemplate;
import com.common.util.AssertUtil;
import com.game.common.MessageCode;
import com.game.common.ZookeeperClient;
import com.game.config.CircleConfig;
import com.game.config.MapConfig;
import com.game.config.RewardConfig;
import com.game.config.RoleConfig;
import com.game.config.TeamConfig;
import com.game.dao.AccountDao;
import com.game.dao.AccountScoreDao;
import com.game.dao.RoomInfoDao;
import com.game.dao.TeamAccountDao;
import com.game.helper.MsgHelper;
import com.game.job.JobScheduler;
import com.game.model.Model;
import com.game.util.GameUtil;
import com.game.vision.VisionAdapter;

@Service
public class RoomService {
	private static final Logger logger = LoggerFactory.getLogger(RoomService.class);
	
//	private static final int waite_enter_cdtime = 120;	// 等待玩家点击确认的CD时间，单位秒
	private static final int waite_enter_cdtime = 20;	// 等待玩家点击确认的CD时间，单位秒
	private static final int waite_start_cdtime = 10;	// 等待开始的CD时间，单位秒
//	private static final int seting_cdtime = 60;		// 设置页面CD时间
	private static final int seting_cdtime = 10;		// 设置页面CD时间
	
	static final int robot_count = 40;					// 生成robot的数量
	static final int ai_count1 = 20;					// 第一个毒圈时生成ai的数量
	static final int ai_count2 = 30;					// 第二个毒圈时生成ai的数量
	static final int ai_count3 = 10;					// 第三个毒圈时生成ai的数量
	
	@Autowired
	private TeamAccountDao teamAccountDao;
	@Autowired
	private GameService gameService;
	@Autowired
	private ChatService chatService;
	@Autowired
	private NpcService npcService;
	@Autowired
	private AccountScoreDao accountScoreDao;
	@Autowired
	private AccountDao accountDao;
	@Autowired
	private RoomInfoDao roomInfoDao;
	@Autowired
	private RoleService roleService;

	public synchronized void ready(Long accountId) {
		TeamAccount teamAccount = teamAccountDao.getTeamAccount(accountId);
		if (teamAccount != null) {
			// 如果是队长，则小队全部准备了，否则通知队长我点击了准备
			if (TeamRole.getType(teamAccount.getRoleId()) == TeamRole.Leader) {
				List<TeamAccount> teamAccountList = teamAccountDao.getTeamAccountList(teamAccount.getTeamId());
				Account leaderAccount = Model.getInstance().accountMap.get(teamAccount.getAccountId());
				leaderAccount.setState(AccountState.Ready.getIndex());
				accountDao.update(leaderAccount);
				// 匹配2,3,4,5人小队房间
				Room room = marryRoom(teamAccountList.size());
				// 验证小队所有成员是否都准备了
				for (TeamAccount tm : teamAccountList) {
					Account account = Model.getInstance().accountMap.get(tm.getAccountId());
					AssertUtil.asErrorTrue(account != null, String.format("小队成员%s没登录", tm.getAccountId()));
					AssertUtil.asErrorTrue(account.getState() == AccountState.Ready.getIndex(), String.format("小队成员%s还没有准备", account.getId()));
				}
				int time = TimeHelper.getTime();
				// 新进入房间的玩家
				List<Long> heroIdList = new ArrayList<Long>();
				// 把小队成员全部拉进房间
				for (TeamAccount tm : teamAccountList) {
					Account account = Model.getInstance().accountMap.get(tm.getAccountId());
					Role role = roleService.getDefault(account.getId());
					RoleTemplate roleTemplate = RoleConfig.map.get(role.getTemplateId());
					// 创建玩家角色
					Hero currHero = new Hero();
					currHero.awtar = account.getAwtar();
					currHero.nick = account.getNick();
					currHero.accountId = account.getId();
					currHero.isTest = account.getIsTest() > 0;
					currHero.isNpc = false;
					currHero.roomId = room.id;
					currHero.teamId = tm.getTeamId();
					currHero.readyTime = time;
					// 计算角色血量上限加成
					currHero.maxhp = roleTemplate.getHp() + (int)(roleTemplate.getHp() * roleTemplate.getHpAdd());
					currHero.hp = currHero.maxhp;
					currHero.speed = HeroConstant.default_speed + HeroConstant.default_speed * roleTemplate.getSpeedAdd() / 100.0f;
					currHero.roleTemplate = roleTemplate;
					// 计算装备血量上限加成
					roleService.calEquipAddition(role, currHero);
					room.heroMap.put(currHero.accountId, currHero);
					heroIdList.add(account.getId());
					Model.getInstance().heroMap.put(currHero.accountId, currHero);
					logger.info(String.format("玩家准备游戏 heroId=%d, roomId=%d", currHero.accountId, currHero.roomId));
					// 在通道上设置房间Id
					ChannelUtil.setRoomId(currHero.accountId, currHero.roomId);
				}
				room.teamCount++;
				TeamTemplate teamTemplate = TeamConfig.map.get(room.teamType);
				// 如果达到房间容纳小队数量上限，则直接发送确认
				if (room.teamCount >= teamTemplate.getCreateRoomCondition()) {
					JobKey jobKey = JobScheduler.generateSendEnterJobKey(room);
					JobScheduler.stopJob(jobKey);
					sendEnter(room, heroIdList);
				}
			} else {
				List<TeamAccount> teamAccountList = teamAccountDao.getTeamAccountList(teamAccount.getTeamId());
				Optional<TeamAccount> op = teamAccountList.stream().filter(tm -> TeamRole.getType(tm.getRoleId()) == TeamRole.Leader).findFirst();
				AssertUtil.asErrorTrue(op.isPresent(), "没找到队长");
				TeamAccount leaderTeamAccount = op.get();
				Account leaderAccount = Model.getInstance().accountMap.get(leaderTeamAccount.getAccountId());
				AssertUtil.asErrorTrue(leaderAccount != null, String.format("队长%s不在线", leaderTeamAccount.getAccountId()));
				Account account = Model.getInstance().accountMap.get(accountId);
				AssertUtil.asErrorTrue(account != null, String.format("玩家%s不在线", account.getId()));
				// 设置为准备状态
				account.setState(AccountState.Ready.getIndex());
				accountDao.update(account);
				// 通知队长我(小队成员)点击了准备
				Message msg = new Message();
				msg.setMsgcd(MessageCode.msg_room_ready_notice);
				msg.putLong(accountId);
				MsgSender.sendMsg(msg, leaderAccount.getId());
			}
		} else {
			// 匹配单人小队房间
			Room room = marryRoom(1);
			Account account = Model.getInstance().accountMap.get(accountId);
			Role role = roleService.getDefault(account.getId());
			RoleTemplate roleTemplate = RoleConfig.map.get(role.getTemplateId());
			// 设置玩家为准备状态
			account.setState(AccountState.Ready.getIndex());
			accountDao.update(account);
			// 创建玩家角色
			Hero currHero = new Hero();
			currHero.awtar = account.getLoginName();
			currHero.nick = account.getNick();
			currHero.accountId = account.getId();
			currHero.isTest = account.getIsTest() > 0;
			currHero.isNpc = false;
			currHero.roomId = room.id;
			currHero.teamId = 0;
			currHero.readyTime = TimeHelper.getTime();
			// 计算角色血量上限加成
			currHero.maxhp = roleTemplate.getHp() + (int)(roleTemplate.getHp() * roleTemplate.getHpAdd());
			currHero.hp = currHero.maxhp;
			currHero.speed = HeroConstant.default_speed + HeroConstant.default_speed * roleTemplate.getSpeedAdd() / 100.0f;
			currHero.roleTemplate = roleTemplate;
			// 计算装备血量上限加成
			roleService.calEquipAddition(role, currHero);
			room.heroMap.put(currHero.accountId, currHero);
			Model.getInstance().heroMap.put(currHero.accountId, currHero);
			logger.info(String.format("玩家准备游戏 heroId=%d, roomId=%d", currHero.accountId, currHero.roomId));
			// 在通道上设置房间Id
			ChannelUtil.setRoomId(currHero.accountId, currHero.roomId);
			room.teamCount++;
			TeamTemplate teamTemplate = TeamConfig.map.get(room.teamType);
			// 如果达到房间容纳小队数量上限，则直接发送确认
			if (room.teamCount >= teamTemplate.getCreateRoomCondition()) {
				JobKey jobKey = JobScheduler.generateSendEnterJobKey(room);
				JobScheduler.stopJob(jobKey);
				sendEnter(room, Arrays.asList(accountId));
			}
		}
	}
	
	private Room marryRoom(int teamAccountCount) {
		TeamTemplate teamTemplate = TeamConfig.map.get(teamAccountCount);
		// 匹配合适的房间给该队
		Optional<Room> optional = Model.getInstance().roomMap.values().stream().filter(room -> room.state == RoomState.Ready || room.state == RoomState.Wait)
				.filter(room -> room.teamType == teamTemplate.getId()).findFirst();
		Room room;
		// 如果匹配到房间，则锁定该房间，否则创建新的房间
		if (optional.isPresent()) {
			room = optional.get();
		} else {
			room = Model.getInstance().createRoom();
			room.state = RoomState.Ready;
			// 载入随机坐标点
			room.locationList.addAll(MapConfig.locationList);
			room.teamType = teamAccountCount;
			Model.getInstance().roomMap.put(room.id, room);
			// 创建发送通知job
			JobScheduler.createSendEnterJob(room, waite_enter_cdtime * 1000);
		}
		return room;
	}
	
	public void marryHero(Room room, JobKey jobKey) {
		if (room.heroMap.size() > 0) {
			if (room.state == RoomState.Ready) {
				// 没有点确认的玩家
				List<Hero> notEnterHeroList = room.heroMap.values().stream().filter(r -> !r.isEnter).collect(Collectors.toList());
				// 剔除房间里没有点确认玩家所在的小队成员
				for (Hero hero : notEnterHeroList) {
					// 如果玩家是小队成员，则剔除该小队成员
					if (hero.teamId > 0) {
						boolean isHas = room.heroMap.values().stream().anyMatch(r -> GameUtil.isTeammate(r, hero));
						// 如果房间里面有该小队的成员，则剔除该小队成员
						if (isHas) {
							List<Hero> teamHeroList = room.heroMap.values().stream().filter(r -> GameUtil.isTeammate(r, hero)).collect(Collectors.toList());
							for (Hero r : teamHeroList) {
								// 剔除房间里没有点确认玩家所在的小队成员
								room.heroMap.remove(r.accountId);
								// 通知没有确认的玩家回到主页
								Message message = new Message();
								message.setMsgcd(MessageCode.msg_room_back_notice);
								MsgSender.sendMsg(message, r.accountId);
							}
							room.teamCount--;
						}
					} else {
						// 通知没有确认的玩家回到主页
						Message message = new Message();
						message.setMsgcd(MessageCode.msg_room_back_notice);
						MsgSender.sendMsg(message, hero.getAccountId());
						room.heroMap.remove(hero.getAccountId());
						room.teamCount--;
					}
				}
				// 如果没有玩家确认，则回收房间
				if (room.heroMap.size() == 0) {
					Model.getInstance().roomMap.remove(room.id);
					JobScheduler.stopJob(jobKey);
				} else {
					if (CollectionUtils.isNotEmpty(notEnterHeroList)) {
						List<Long> heroIdList = new ArrayList<Long>();
						for (Iterator<Hero> it = room.heroMap.values().iterator(); it.hasNext();) {
							Hero hero = it.next();
							// 重新设置为未确认
							hero.isEnter = false;
							heroIdList.add(hero.accountId);
						}
						sendEnter(room, heroIdList);
					}
				}
			}
		}
	}
	
	public void cancelReady(Long accountId) {
		Hero hero = Model.getInstance().heroMap.get(accountId);
		Account account = Model.getInstance().accountMap.get(accountId);
		account.setState(AccountState.Online.getIndex());
		accountDao.update(account);
		AssertUtil.asWarnTrue(hero != null, "玩家角色未找到");
		Room room = Model.getInstance().roomMap.get(hero.roomId);
		if (room != null) {
			AssertUtil.asWarnTrue(room.state == RoomState.Ready, "房间状态为准备时才能取消");
			room.heroMap.remove(hero.accountId);
		}
	}
	
	public void sendEnter(Room room, List<Long> heroIdList) {
		// 发送确认通知
		MsgHelper.broadcastEnterNotice(waite_enter_cdtime, room, heroIdList);
		// 匹配玩家
		JobScheduler.createMarryHeroJob(room, waite_start_cdtime * 1000);
	}
	
	public void enterGame(Long accountId) {
		Hero currHero = Model.getInstance().heroMap.get(accountId);
		currHero.isEnter = true;
		Room room = Model.getInstance().roomMap.get(currHero.roomId);
		if (room != null) {
			synchronized(room) {
				if (room.state == RoomState.Ready) {
					// 玩家是否全部确认
					boolean isAllEnter = room.heroMap.values().stream().allMatch(r -> r.isEnter);
					// 如果玩家全部确认，则进入设置页面
					if (isAllEnter) {
						// 获取房间里的小队Id列表
						List<Long> teamIdList = room.heroMap.values().stream().map(r -> r.teamId).collect(Collectors.toList());
						boolean isPass = true;
						for (Long teamId : teamIdList) {
							List<TeamAccount> tmList = teamAccountDao.getTeamAccountList(teamId);
							if (CollectionUtils.isNotEmpty(tmList)) {
								// 检查点击确认的每个玩家所在小队成员都点击了确认，则进入设置页面
								isPass = tmList.stream().allMatch(tm -> room.heroMap.get(tm.getAccountId()) != null);
								if (!isPass) {
									break;
								}
							}
						}
						if (isPass) {
							intoSeting(room);
						}
					}
				}
			}
		}
	}
	
	public synchronized Location setBirthplace(Long accountId, float x, float z) {
		Hero hero = Model.getInstance().heroMap.get(accountId);
		Room room = Model.getInstance().roomMap.get(hero.roomId);
		Location selectLocation = new Location(x, 0f, z);
		List<Location> locationList = new ArrayList<Location>();
		for (Location location : room.locationList) {
			if (GameUtil.distance(selectLocation, location) < 10) {
				locationList.add(location);
			}
		}
		Location birthplaceLocation = locationList.remove(RandomHelper.getRandom(0, locationList.size() - 1));
		room.locationList.remove(birthplaceLocation);
		hero.location = new Location(351f, 0f, 338f);
		logger.info(String.format("出生地x=%s z=%s", hero.location.x, hero.location.z));
		Model.getInstance().heroMap.put(hero.accountId, hero);
		return birthplaceLocation;
	}
	
	/**
	 * 进入设置页面，等待玩家设置出生地和设置自身技能，等待后开始游戏
	 */
	public synchronized void intoSeting(final Room room) {
		if (room.state == RoomState.Ready || room.state == RoomState.Wait) {
			List<Long> heroIdList = room.heroMap.values().stream().filter(r -> {return !r.isNpc && !r.isExit;}).map(Hero::getAccountId).collect(Collectors.toList());
			MsgHelper.broadcastCDTime(seting_cdtime, room, heroIdList);
			// 等待玩家设置出生地和设置自身技能，等待后开始游戏
			JobScheduler.createStartGameJob(room, seting_cdtime * 1000);
			RoomInfo roomInfo = new RoomInfo();
			roomInfo.setId(room.id);
			roomInfo.setState(RoomState.Ready);
			roomInfoDao.update(roomInfo);
		}
	}

	/**
	 * 开始游戏
	 */
	public void startGame(Room room) {
		if (room.state == RoomState.Wait || room.state == RoomState.Ready) {
			String tid = chatService.createChatRoom(room);
			room.tid = tid;
			// 生成宝箱
			generateBox(room);
			// 检查真实玩家是否设置了出生地，如果没有设置出生地，则随机一个出生地给玩家
			checkBirthplace(room);
			CircleTemplate bigTemplate = CircleConfig.map.get(1);
			Location bigCenter = CircleConstant.mapCenter;
			// 预先生成NPC
			generateNpc(room);
			logger.info("startGame 创建第一个毒圈");
			createCircle(room, bigTemplate, bigCenter, bigTemplate.getRadius());
			logger.info(String.format("游戏%d开始", room.id));
			room.state = RoomState.Start;
			// 进入游戏
			int vision = HeroConstant.not_debug_vision;
			Set<Long> heroIdSet = room.heroMap.keySet();
			for (Iterator<Long> it = heroIdSet.iterator(); it.hasNext();) {
				Long heroId = it.next();
				Hero hero = room.heroMap.get(heroId);
				if (hero.isNpc) {
					List<Hero> visionHeroList = VisionAdapter.getVisionHeroList(hero, room.heroMap, vision);
					// 初始化NPC视野
					List<Hero> inHeroList = VisionAdapter.getInHeroList(hero.visionHeroList, visionHeroList);
					if (CollectionUtils.isNotEmpty(inHeroList)) {
						hero.visionHeroList.addAll(inHeroList);
					}
				} else {
					intoGame(room, hero);
				}
			}
		}
	}

	private void checkBirthplace(Room room) {
		// 检查真实玩家是否设置了出生地，如果没有设置出生地，则随机一个出生地给玩家
		Set<Long> heroIdSet = room.heroMap.keySet();
		for (Iterator<Long> it = heroIdSet.iterator(); it.hasNext();) {
			Long heroId = it.next();
			Hero hero = room.heroMap.get(heroId);
			if (!hero.isNpc) {
				// 如果玩家没有设置出生地，则随机一个出生地给玩家
				if (hero.location == null) {
					Location location = room.locationList.get(RandomHelper.getRandom(0, room.locationList.size() - 1));
					setBirthplace(hero.accountId, location.x, location.z);
				}
			}
		}
	}

	private void generateBox(Room room) {
		for (int i = 0; i < BoxConstant.room_box_count; i++) {
			if (room.locationList.size() > 0) {
				Box box = new Box();
				box.id = (short)(i + 1);
				byte hp;
				int rd = RandomHelper.getRandom(1, 100);
				byte level;
				if (rd >= 1 && rd < 62) {
					level = 1;
					hp = BoxConstant.box_level1_hp;
				} else if (rd >= 63 && rd < 92) {
					level = 2;
					hp = BoxConstant.box_level2_hp;
				} else {
					level = 3;
					hp = BoxConstant.box_level3_hp;
				}
				box.level = level;
				box.hp = hp;
				Location location = room.locationList.remove(RandomHelper.getRandom(0, room.locationList.size() - 1));
				box.location = new Location(location.x, 0f, location.z);
				room.boxMap.put(box.id, box);
			} else {
				break;
			}
		}
	}
	
	public void generateNpc(Room room) {
		int realHeroCount = room.heroMap.size();
		int robotCount = HeroConstant.room_hero_count - (robot_count - realHeroCount);
		RoleTemplate roleTemplate = RoleConfig.map.get(HeroConstant.default_role_templateId);
		
		for (int i = 0; i < robotCount; i++) {
			Hero robot = new Hero();
			// 随机产生
			robot.accountId = 1L + i;
			robot.awtar = String.format("robot_%s_%s", room.id, robot.accountId);
			robot.nick = String.format("robot_%s_%s", room.id, robot.accountId);
			robot.isNpc = true;
			robot.roomId = room.id;
			robot.maxhp = roleTemplate.getHp() + (int)(roleTemplate.getHp() * roleTemplate.getHpAdd());
			robot.hp = robot.maxhp;
			robot.speed = HeroConstant.default_speed + HeroConstant.default_speed * roleTemplate.getSpeedAdd() / 100.0f;
			robot.roleTemplate = roleTemplate;
			room.robotList.add(robot);
		}
		logger.info(String.format("生成robot人数为%s", room.robotList.size()));
		int aiCount = HeroConstant.room_hero_count - realHeroCount - robotCount;
		for (int i = 0; i < aiCount; i++) {
			Hero ai = new Hero();
			// 随机产生
			ai.accountId = 101L + i;
			ai.awtar = String.format("ai_%s_%s", room.id, ai.accountId);
			ai.nick = String.format("ai_%s_%s", room.id, ai.accountId);
			ai.isNpc = true;
			ai.roomId = room.id;
			ai.maxhp = roleTemplate.getHp() + (int)(roleTemplate.getHp() * roleTemplate.getHpAdd());
			ai.hp = ai.maxhp;
			ai.speed = HeroConstant.default_speed + HeroConstant.default_speed * roleTemplate.getSpeedAdd() / 100.0f;
			ai.roleTemplate = roleTemplate;
			room.aiList.add(ai);
		}
		logger.info(String.format("生成ai人数为%s", room.aiList.size()));
	}
	
	public void createRobot(Room room, int count) {
		if (count > 0) {
			if (room.robotList.size() > 0) {
				if (count > 0) {
					Hero robot = room.robotList.remove(0);
					// 随机出生位置
					List<Short> boxList = room.boxMap.keySet().stream().collect(Collectors.toList());
					Short boxId = boxList.get(RandomHelper.getRandom(0, boxList.size() - 1));
					Box box = room.boxMap.get(boxId);
					Target target = new Target(box);
					robot.reTarget = target;
					robot.location = new Location(425f, 0f, 282f);
//					robot.location = randomLocation(room);
					robot.teamId = room.teamId.incrementAndGet();
					room.heroMap.put(robot.accountId, robot);
					logger.info(String.format("创建robotId=%s nick=%s location=%s reTarget=%s", robot.accountId, robot.nick, robot.location, target));
					// 更新视野范围内玩家
					gameService.updateVisionHero(room, robot);
					// 更新视野范围内宝箱
					gameService.updateVisionBox(room, robot);
					// 更新视野范围内技能书
					gameService.updateVisionBook(room, robot);
					// 创建变更任务线程
					JobScheduler.createChangeTask(room, robot);
					// 安装技能
					upSkill(robot);
					// 创建下一个Robot
					JobScheduler.createJoinRobotJob(room, --count, 0);
				}
			}
		}
	}
	
	public void upSkill(Hero hero) {
		for (int i = 0; i < 8; i++) {
			int index = RandomHelper.getRandom(0, TemplateConstant.templateIdList.size() - 1);
			int templateId = TemplateConstant.templateIdList.get(index);
			Skill skill = new Skill(templateId);
			hero.skillBag.add(skill);
		}
		npcService.setupSkill(hero);
	}
	
	private Location getLocationForInCircle(Room room) {
		Location result = null;
		for (; true; ) {
			Location location = room.locationList.get(RandomHelper.getRandom(0, room.locationList.size() - 1));
			double distance = GameUtil.distance(room.circle.center, location);
			if (distance <= room.circle.radius) {
				result = location;
				break;
			}
		}
		return result;
	}
	
	public void createTestBox(Room room) {
		if (room.locationList.size() > 0) {
			Box box = new Box();
			box.id = (short)1;
			byte hp;
			int rd = RandomHelper.getRandom(1, 100);
			byte level;
			if (rd >= 1 && rd < 62) {
				level = 1;
				hp = BoxConstant.box_level1_hp;
			} else if (rd >= 63 && rd < 92) {
				level = 2;
				hp = BoxConstant.box_level2_hp;
			} else {
				level = 3;
				hp = BoxConstant.box_level3_hp;
			}
			box.level = level;
			box.hp = hp;
			box.location = new Location(321, 0f, 286);
			room.boxMap.put(box.id, box);
		}
		
		if (room.locationList.size() > 0) {
			Box box = new Box();
			box.id = (short)2;
			byte hp;
			int rd = RandomHelper.getRandom(1, 100);
			byte level;
			if (rd >= 1 && rd < 62) {
				level = 1;
				hp = BoxConstant.box_level1_hp;
			} else if (rd >= 63 && rd < 92) {
				level = 2;
				hp = BoxConstant.box_level2_hp;
			} else {
				level = 3;
				hp = BoxConstant.box_level3_hp;
			}
			box.level = level;
			box.hp = hp;
			box.location = new Location(324, 0f, 286);
			room.boxMap.put(box.id, box);
		}
	}
	
	public void createAi(Room room, int count) {
		if (count > 0) {
			if (room.aiList.size() > 0) {
				List<Hero> targetHeroList = room.heroMap.values().stream().filter(hero -> !hero.isNpc || hero.accountId < 100).collect(Collectors.toList());
				Hero ai = room.aiList.remove(0);
				Target target;
				if (targetHeroList.size() > 0) {
					Hero hero = targetHeroList.remove(RandomHelper.getRandom(0, targetHeroList.size() - 1));
					target = new Target(hero);
				} else {
					Location targetLocation = getLocationForInCircle(room);
					target = new Target(targetLocation);
				}
				ai.reTarget = target;
//				ai.location = randomLocation(room);
				ai.location = new Location(350f, 0f, 340f);
				logger.info(String.format("创建ai=%s nick=%s location=%s reTarget=%s", ai.accountId, ai.nick, ai.location, ai.reTarget));
				ai.teamId = room.teamId.incrementAndGet();
				room.heroMap.put(ai.accountId, ai);
				// 更新视野范围内玩家
				gameService.updateVisionHero(room, ai);
				// 更新视野范围内宝箱
				gameService.updateVisionBox(room, ai);
				// 更新视野范围内技能书
				gameService.updateVisionBook(room, ai);
				// 创建变更任务线程
				JobScheduler.createChangeTask(room, ai);
				// 安装技能
				upSkill(ai);
				// 创建下一个AI
				JobScheduler.createJoinAiJob(room, --count, 0);
			}
		}
	}
	
	public Location randomLocation(Room room) {
		int vision = HeroConstant.not_debug_vision + 10;
		for (; true; ) {
			// 出生位置必须满足不在真实玩家视野范围内，因为如果在真实玩家视野范围内，就会让人感觉突然有个人出现在面前
			Location location = room.locationList.get(RandomHelper.getRandom(0, room.locationList.size() - 1));
			Set<Long> heroIdSet = room.heroMap.keySet();
			boolean isHasPlayer = false;	// 是否视野范围内存在真实玩家
			for (Iterator<Long> it = heroIdSet.iterator(); it.hasNext();) {
				Hero hero = room.heroMap.get(it.next());
				if (!hero.isNpc) {
					float d = GameUtil.distance(location, hero.location);
					if (d <= vision) {
						isHasPlayer = true;
						break;
					}
				}
			}
			// 如果范围内没有真实玩家，则返回位置
			if (!isHasPlayer) {
				return location;
			}
		}
	}
	
	public void createCircle(Room room, CircleTemplate bigTemplate, Location bigCenter, float bigRadius) {
		// 小圆模板
		CircleTemplate smallTemplate = CircleConfig.map.get(bigTemplate.getId() + 1);
		float smallRadius = 0;
		if (smallTemplate != null) {
			smallRadius = smallTemplate.getRadius();
		}
		// 小圆圆心
		Location smallCenter = calNextCenter(bigTemplate, bigCenter, bigRadius);
		// 缩圈时间
		int liftime = bigTemplate.getLiftime();
		// 计算缩圈速度 = (大圈半径 - 小圈半径) / 缩圈时间
		float shrinkSpeed = (bigRadius - smallRadius) * 1.0f / liftime * CircleConstant.interval / 1000.0f;
		// 根据当前圆心和下一个圆心，计算圆心点轨迹列表
		List<Location> locationList = calcCenterList(bigCenter, smallCenter, liftime);
		Circle circle = new Circle();
		circle.center = bigCenter;
		circle.smallCenter = smallCenter;
		circle.templateId = bigTemplate.getId();
		circle.radius = bigTemplate.getRadius();
		circle.shrinkSpeed = shrinkSpeed;
		circle.circleBegin = TimeHelper.getTime();
		circle.circleLiftime = liftime + bigTemplate.getStay();
		circle.locationList = locationList;
		room.circle = circle;
		if (circle.templateId == 1) {
			/*// 填充60个玩家，包括真实玩家和AI
			int realHeroCount = room.heroMap.size();
			// 机器人向圈靠近，如果AI在圈内，则随机一个坐标点为目标移动
			JobScheduler.createJoinRobotJob(room, robot_count - realHeroCount, 20);
			// 给AI设定一个目标(这个目标可能是真实玩家，也可能是机器人)，自动寻路找这个目标攻击
			JobScheduler.createJoinAiJob(room, ai_count1, 20);*/
			JobScheduler.createJoinAiJob(room, 1, 0);
		} else if (circle.templateId == 2) {
//			JobScheduler.createJoinAiJob(room, ai_count2, 0);
		} else if (circle.templateId == 3) {
//			JobScheduler.createJoinAiJob(room, ai_count3, 0);
		}
		MsgHelper.broadcastCircle(room, bigTemplate, smallRadius, circle);
	}
	
	/**
	 * 计算小圆圆心
	 **/
	private Location calNextCenter(CircleTemplate bigTemplate, Location bigCenter, float bigRadius) {
		logger.info(String.format("大圆圆(%s, %s) radius=%s", bigCenter.x, bigCenter.z, bigRadius));
		Location smallCenter = null;
		if (bigTemplate.getId() >= CircleConfig.last_templateId) {
			return bigCenter;
		} else {
			CircleTemplate smallTemplate = CircleConfig.map.get(bigTemplate.getId() + 1);
			int smallRadius = 0;
			if (smallTemplate != null) {
				smallRadius = smallTemplate.getRadius();
			}
			float r = bigRadius - smallRadius;
			// 计算小圆圆心
			// 以大圆和小圆的半径差为半径，大圆圆心为圆心画一个虚线圆，在这个虚线圆内随机一个点作为下一个圆的圆心
			for (int i = 0; i < 1000; i++) {
				// 大圆半径减去小圆的半径
				// 随机坐标x
				float x = RandomHelper.getRandom(bigCenter.x - r, bigCenter.x + r);
				// 随机坐标z
				float z = RandomHelper.getRandom(bigCenter.z - r, bigCenter.z + r);
				boolean isRange = MapConfig.isRoad(x, z);
				logger.info(String.format("x1=%s z1=%s r=%s x2=%s z2=%s isRange=%s", bigCenter.x, bigCenter.z, r, x, z, isRange));
				// 如果坐标点是否在地图可行走范围内，则选中作为小圆圆心点
				if (isRange) {
					Location center = new Location(x, 0f, z);
					// 大圆和随机圆的圆心距
					float d = GameUtil.distance(bigCenter, center);
					logger.info(String.format("x1=%s z1=%s r=%s x2=%s z2=%s d=%s", bigCenter.x, bigCenter.z, r, x, z, d));
					// 因为随机的点是以正方形为中心随机，所以有可能随机的点不在虚线圆内
					// 如果随机点和虚线圆的圆心距离小于虚线圆半径，则随机点在虚线圆内
					if (d <= r) {
						smallCenter = center;
						break;
					}
				}
			}
			logger.info(String.format("小圆圆心(%s, %s) radius=%s", smallCenter.x, smallCenter.z, smallRadius));
			return smallCenter;
		}
	}
	
	private List<Location> calcCenterList(Location currCenter, Location nextCenter, int liftime) {
		float distance = GameUtil.distance(currCenter, nextCenter);
		float speed = distance / (liftime * CircleConstant.interval);
		double angle = (float)GameUtil.angle(currCenter, nextCenter);
		List<Location> locationList = new ArrayList<Location>();
		Location center = currCenter;
		for (int i = 1; i < liftime; i++) {
			double addx = Math.sin(angle) * speed;
			double addz = Math.cos(angle) * speed;
			int coefficientx = nextCenter.x > center.x ? 1 : -1;
			int coefficientz = nextCenter.z > center.z ? 1 : -1;
			float x = (float)(center.x + addx * coefficientx);
			float z = (float)(center.z + addz * coefficientz);
			x = Math.round(x * 100) / 100;
			z = Math.round(z * 100) / 100;
			Location location = new Location(x, 0f, z);
			locationList.add(location);
			center = location;
		}
		locationList.add(nextCenter);
		return locationList;
	}
	
	/**
	 * 进入游戏
	 */
	public void intoGame(Long accountId) {
		Hero hero = Model.getInstance().heroMap.get(accountId);
		AssertUtil.asWarnTrue(hero != null, "玩家不存在");
		AssertUtil.asWarnTrue(hero.hp > 0, "玩家已阵亡");
		Room room = Model.getInstance().roomMap.get(hero.roomId);
		AssertUtil.asWarnTrue(room != null, "房间不存在");
		intoGame(room, hero);
	}
	
	private void intoGame(Room room, Hero currHero) {
		Account account = Model.getInstance().accountMap.get(currHero.accountId);
		// 设置玩家为游戏中
		account.setState(AccountState.Gaming.getIndex());
		accountDao.update(account);
		MsgHelper.getMyInfo(room, currHero);
	}

	public void continueOrAgain(Long accountId, byte continueOrAgain) {
		AssertUtil.asWarnTrue(continueOrAgain >= RoomConstant.continue_game && continueOrAgain <= RoomConstant.again_game, "参数错误");
		Hero hero = Model.getInstance().heroMap.get(accountId);
		if (hero != null) {
			if (continueOrAgain == RoomConstant.continue_game) {
				hero.isExit = false;
				hero.isDeserter = false;
			} else {
				Room room = Model.getInstance().roomMap.get(hero.roomId);
				if (room != null) {
					room.heroMap.remove(hero.accountId);
					Model.getInstance().heroMap.remove(hero.accountId);
					gameService.stopRoomJob(room, false, 2);
				}
			}
		}
	}
	
	public void loadFinish(Long accountId) {
		Hero hero = Model.getInstance().heroMap.get(accountId);
		AssertUtil.asWarnTrue(hero != null, "玩家不存在");
		AssertUtil.asWarnTrue(hero.hp > 0, "玩家已阵亡");
		Room room = Model.getInstance().roomMap.get(hero.roomId);
		AssertUtil.asWarnTrue(room != null, "房间不存在");
		hero.isLoadFinish = true;
		// 更新视野范围内玩家
		gameService.updateVisionHero(room, hero);
		// 更新视野范围内宝箱
		gameService.updateVisionBox(room, hero);
		// 更新视野范围内技能书
		gameService.updateVisionBook(room, hero);
		// 发送视野范围内宝箱
		MsgHelper.sendBoxList(hero, room);
	}
	
	public void backRoom(Long accountId) {
		Account account = Model.getInstance().accountMap.get(accountId);
    	// 设置玩家为在线状态
    	account.setState(AccountState.Online.getIndex());
    	accountDao.update(account);
	}
	
	public void getOnlineList(Long accountId, Integer pageIndex, Integer pageSize) {
		AssertUtil.asWarnTrue(accountId != null && accountId > 0, "我的Id参数错误");
		AssertUtil.asWarnTrue(pageIndex >= 0, "pageIndex参数错误");
		Hero currHero = Model.getInstance().heroMap.get(accountId);
		AssertUtil.asWarnTrue(currHero != null, "玩家不存在");
		List<Account> accountList = Model.getInstance().accountMap.values().stream().filter(m -> m.getId().longValue() != accountId).collect(Collectors.toList());
		int pageCount = accountList.size() / pageSize + accountList.size() % pageSize > 0 ? 1 : 0;
		int fromIndex = pageIndex * pageSize;
		int toIndex = (pageIndex + 1) * pageSize;
		List<Account> currPageList;
		if (pageCount > pageIndex) {
			currPageList = accountList.subList(fromIndex, toIndex);
		} else {
			currPageList = new ArrayList<Account>();
		}
		MsgHelper.sendOnlineList(currHero, pageCount, currPageList);
	}
	
	public void recoveryRoom(Room room) {
		logger.info(String.format("准备回收房间room.id=%s", room.id));
		room.state = RoomState.End;
		Model.getInstance().roomMap.remove(room.id);
		String groupName = String.format("%s_", room.id);
		// 结束Quartz线程
		JobScheduler.stopGroup(groupName);
		// 保存战绩信息
		saveScore(room);
		logger.info(String.format("回收房间 room.id=%s", room.id));
	}
	
	@SuppressWarnings("unchecked")
	private void saveScore(Room room) {
		List<Hero> heroList = room.heroMap.values().stream().filter(r -> !r.isNpc).collect(Collectors.toList());
		List<Hero> deadList = room.deadMap.values().stream().filter(r -> !r.isNpc).collect(Collectors.toList());
		heroList.addAll(deadList);
		for (Hero hero : heroList) {
			AccountScore ms = accountScoreDao.getByAccountId(hero.accountId);
			Map<String, Integer> scoreMap;
			if (ms == null) {
				scoreMap = new HashMap<String, Integer>();
			} else {
				scoreMap = (Map<String, Integer>)CBUtils.getObjectFromBytes(ms.getObj());
			}
			increment(scoreMap, room.teamType, SubjectConstant.attack_hp, hero.attackHp);
			increment(scoreMap, room.teamType, SubjectConstant.be_attack_hp, hero.beAttackHp);
			increment(scoreMap, room.teamType, SubjectConstant.treat_hp, hero.treatHp);
			increment(scoreMap, room.teamType, SubjectConstant.kill_count, hero.killCount);
			increment(scoreMap, room.teamType, SubjectConstant.move_distance, (int)hero.moveDistance);
			// 如果逃跑了，则记录逃跑次数
			if (hero.isDeserter) {
				increment(scoreMap, room.teamType, SubjectConstant.desert_count, 1);
			}
			increment(scoreMap, room.teamType, SubjectConstant.game_count, 1);
			Set<Integer> usedSkillTemplateIdSet = hero.usedSkillTemplateIdCount.keySet();
			for (Iterator<Integer> it = usedSkillTemplateIdSet.iterator(); it.hasNext();) {
				Integer skillTemplateId = it.next();
				Integer value = hero.usedSkillTemplateIdCount.get(skillTemplateId);
				increment(scoreMap, room.teamType, skillTemplateId, value);
			}
			// 记录名次
			if (hero.rank == 1) {
				increment(scoreMap, room.teamType, SubjectConstant.rank_first, 1);
			}
			if (hero.rank <= 3) {
				increment(scoreMap, room.teamType, SubjectConstant.top_three, 1);
			}
			if (hero.rank <= 10) {
				increment(scoreMap, room.teamType, SubjectConstant.top_ten, 1);
			}
			RewardTemplate rewardTemplate = RewardConfig.map.get(hero.rank);
			if (rewardTemplate != null) {
				accountDao.updateGb(hero.accountId, -rewardTemplate.getGb());
			}
			byte[] bytes = CBUtils.getBytesFromObject(scoreMap);
			AccountScore accountScore = new AccountScore();
			accountScore.setAccountId(hero.accountId);
			accountScore.setObj(bytes);
			accountScoreDao.replace(accountScore);
		}
	}
	
	private void increment(Map<String, Integer> scoreMap, int teamType, int subject, int addValue) {
		String key = String.format("%d_%d", teamType, subject);
		Integer value = scoreMap.get(key);
		value = value == null ? addValue : value + addValue;
		scoreMap.put(key, value);
	}
	
	public void getScoreInfo(long accountId) {
		Message msg = new Message();
		msg.setMsgcd(MessageCode.msg_room_score_info);
		AccountScore accountScore = accountScoreDao.getByAccountId(accountId);
		@SuppressWarnings("unchecked")
		Map<String, Integer> scoreMap = (Map<String, Integer>)CBUtils.getObjectFromBytes(accountScore.getObj());
		// 获取单人组战绩信息
		getTeamTypeScoreInfo(msg, 1, accountId, scoreMap);
		// 获取二人组战绩信息
		getTeamTypeScoreInfo(msg, 2, accountId, scoreMap);
		// 获取五人组战绩信息
		getTeamTypeScoreInfo(msg, 5, accountId, scoreMap);
		MsgSender.sendMsg(msg);
	}
	
	public void getTeamTypeScoreInfo(Message msg, int teamType, long accountId, Map<String, Integer> scoreMap) {
		// 夺得第一名次数
		int firstCount = getScoreValue(teamType, SubjectConstant.rank_first, scoreMap);
		// 夺得前三名次数
		int top3Count = getScoreValue(teamType, SubjectConstant.top_three, scoreMap);
		// 夺得前十名次数
		int top10Count = getScoreValue(teamType, SubjectConstant.top_ten, scoreMap);
		// 总局数
		int gameCount = getScoreValue(teamType, SubjectConstant.game_count, scoreMap);
		// 输出量
		int attackHp = getScoreValue(teamType, SubjectConstant.attack_hp, scoreMap);
		// 承受伤害量
		int beAttackHp = getScoreValue(teamType, SubjectConstant.be_attack_hp, scoreMap);
		// 治疗量
		int treatHp = getScoreValue(teamType, SubjectConstant.treat_hp, scoreMap);
		// 击杀量
		int killCount = getScoreValue(teamType, SubjectConstant.kill_count, scoreMap);
		// 击杀量
		int moveDistance = getScoreValue(teamType, SubjectConstant.move_distance, scoreMap);
		// 夺冠率%
		float firstRate = gameCount == 0 ? 0 : GameUtil.round2(firstCount * 100.0 / gameCount);
		// 前三率%
		float top3Rate = gameCount == 0 ? 0 : GameUtil.round2(top3Count * 100.0 / gameCount);
		// 前十率%
		float top10Rate = gameCount == 0 ? 0 : GameUtil.round2(top10Count * 100.0 / gameCount);
		// 平均每局伤害输出量
		int averageAttackHp = gameCount == 0 ? 0 : (int)(attackHp / gameCount);
		// 平均每局承受伤害量
		int averageBeAttackHp = gameCount == 0 ? 0 : (int)(beAttackHp * 100.0 / gameCount);
		// 平局每局治疗量
		int averageTreatHp = gameCount == 0 ? 0 : (int)(treatHp * 100.0 / gameCount);
		// 平均每局击杀数量
		float averageKillCount = gameCount == 0 ? 0 : GameUtil.round2(killCount / gameCount);
		// 平均每局跑步距离
		int averageMoveDistance = gameCount == 0 ? 0 : (int)(moveDistance / gameCount);
		// 最常用技能
		int[] top3SkillTemplateId = getTop3SkillTemplateId(teamType, scoreMap);
		msg.putFloat(firstRate);			// 夺冠率%
		msg.putFloat(top3Rate);				// 前三率%
		msg.putFloat(top10Rate);			// 前十率%
		msg.putInt(averageAttackHp);		// 平均每局伤害输出量
		msg.putInt(averageBeAttackHp);		// 平均每局承受伤害量
		msg.putInt(averageTreatHp);			// 平局每局治疗量
		msg.putInt(killCount);				// 总击杀量
		msg.putInt(gameCount);				// 总局数
		msg.putFloat(averageKillCount);		// 平均每局击杀数量
		msg.putInt(averageMoveDistance);	// 平均每局跑步距离
		msg.putInt(top3SkillTemplateId[0]);	// 最常用技能1
		msg.putInt(top3SkillTemplateId[1]);	// 最常用技能2
		msg.putInt(top3SkillTemplateId[2]);	// 最常用技能3
	}

	private int getScoreValue(int teamType, int subject, Map<String, Integer> scoreMap) {
		String key = String.format("%d_%d", teamType, subject);
		if (scoreMap.containsKey(key)) {
			return scoreMap.get(key);
		} else {
			return 0;
		}
	}
	
	private int[] getTop3SkillTemplateId(int teamType, Map<String, Integer> scoreMap) {
		Set<String> scoreSet = scoreMap.keySet();
		List<KeyValue> scorelist = new ArrayList<KeyValue>();
		for (Iterator<String> it = scoreSet.iterator(); it.hasNext();) {
			String key = it.next();
			Integer value = scoreMap.get(key);
			scorelist.add(new KeyValue(key, value));
		}
		scorelist.sort(Comparator.comparing(kv -> kv.getValue()));
		int[] top3SkillTemplateId = new int[3];
		for (int i = 0; i < 3; i++) {
			if (i < scorelist.size()) {
				KeyValue kv = scorelist.get(i);
				top3SkillTemplateId[i] = (kv.getValue());
			}
		}
		return top3SkillTemplateId;
	}
	
	public Room createRoom(Integer roomId, int teamType) {
		Room room = new Room();
		room.id = roomId;
		room.mapId = 1;
		room.state = RoomState.Wait;
		// 载入随机坐标点
		room.locationList.addAll(MapConfig.locationList);
		room.teamType = teamType;
		Model.getInstance().roomMap.put(room.id, room);
		// 创建发送通知job
		JobScheduler.createSendEnterJob(room, waite_enter_cdtime * 1000);
		return room;
	}
	
	public void connectRoom(Long accountId, Integer roomId) {
		Room room = Model.getInstance().roomMap.get(roomId);
		if (room.state == RoomState.Start) {
			// 该房间游戏已经开始，将状态返回到在线状态，通知客户端回到准备主页
			Account account = accountDao.getById(accountId);
			account.setState(AccountState.Online.getIndex());
			accountDao.update(account);
		} else {
			TeamAccount teamAccount = teamAccountDao.getTeamAccount(accountId);
			if (teamAccount != null) {
				// 如果是队长，则小队全部准备了，否则通知队长我点击了准备
				if (TeamRole.getType(teamAccount.getRoleId()) == TeamRole.Leader) {
					List<TeamAccount> teamAccountList = teamAccountDao.getTeamAccountList(teamAccount.getTeamId());
					Account leaderAccount = Model.getInstance().accountMap.get(teamAccount.getAccountId());
					leaderAccount.setState(AccountState.Ready.getIndex());
					accountDao.update(leaderAccount);
					// 验证小队所有成员是否都准备了
					for (TeamAccount tm : teamAccountList) {
						Account account = Model.getInstance().accountMap.get(tm.getAccountId());
						AssertUtil.asErrorTrue(account != null, String.format("小队成员%s没登录", tm.getAccountId()));
						AssertUtil.asErrorTrue(account.getState() == AccountState.Ready.getIndex(), String.format("小队成员%s还没有准备", account.getId()));
					}
					int time = TimeHelper.getTime();
					// 新进入房间的玩家
					List<Long> heroIdList = new ArrayList<Long>();
					// 把小队成员全部拉进房间
					for (TeamAccount tm : teamAccountList) {
						Account account = Model.getInstance().accountMap.get(tm.getAccountId());
						// 创建玩家角色
						Hero currHero = new Hero();
						currHero.awtar = account.getAwtar();
						currHero.nick = account.getNick();
						currHero.accountId = account.getId();
						currHero.isTest = account.getIsTest() > 0;
						currHero.isNpc = false;
						currHero.roomId = room.id;
						currHero.teamId = tm.getTeamId();
						currHero.readyTime = time;
						room.heroMap.put(currHero.accountId, currHero);
						heroIdList.add(account.getId());
						Model.getInstance().heroMap.put(currHero.accountId, currHero);
						logger.info(String.format("玩家准备游戏 heroId=%d, roomId=%d", currHero.accountId, currHero.roomId));
					}
					room.teamCount++;
					TeamTemplate teamTemplate = TeamConfig.map.get(room.teamType);
					// 如果达到房间容纳小队数量上限，则直接发送确认
					if (room.teamCount * room.teamType >= teamTemplate.getCreateRoomCondition()) {
						JobKey jobKey = JobScheduler.generateSendEnterJobKey(room);
						JobScheduler.stopJob(jobKey);
						sendEnter(room, heroIdList);
					}
				} else {
					List<TeamAccount> teamAccountList = teamAccountDao.getTeamAccountList(teamAccount.getTeamId());
					Optional<TeamAccount> op = teamAccountList.stream().filter(tm -> TeamRole.getType(tm.getRoleId()) == TeamRole.Leader).findFirst();
					AssertUtil.asErrorTrue(op.isPresent(), "没找到队长");
					TeamAccount leaderTeamAccount = op.get();
					Account leaderAccount = Model.getInstance().accountMap.get(leaderTeamAccount.getAccountId());
					AssertUtil.asErrorTrue(leaderAccount != null, String.format("队长%s不在线", leaderTeamAccount.getAccountId()));
					Account account = Model.getInstance().accountMap.get(accountId);
					AssertUtil.asErrorTrue(account != null, String.format("玩家%s不在线", account.getId()));
					// 设置为准备状态
					account.setState(AccountState.Ready.getIndex());
					accountDao.update(account);
					// 通知队长我(小队成员)点击了准备
					Message msg = new Message();
					msg.setMsgcd(MessageCode.msg_room_ready_notice);
					msg.putLong(accountId);
					MsgSender.sendMsg(msg, leaderAccount.getId());
				}
			} else {
				Account account = accountDao.getById(accountId);
				// 设置玩家为准备状态
				account.setState(AccountState.Ready.getIndex());
				accountDao.update(account);
				// 创建玩家角色
				Hero currHero = new Hero();
				currHero.awtar = account.getLoginName();
				currHero.nick = account.getNick();
				currHero.accountId = account.getId();
				currHero.isTest = account.getIsTest() > 0;
				currHero.isNpc = false;
				currHero.roomId = room.id;
				currHero.teamId = 0;
				currHero.readyTime = TimeHelper.getTime();
				room.heroMap.put(currHero.accountId, currHero);
				Model.getInstance().heroMap.put(currHero.accountId, currHero);
				logger.info(String.format("玩家准备游戏 heroId=%d, roomId=%d", currHero.accountId, currHero.roomId));
				room.teamCount++;
				TeamTemplate teamTemplate = TeamConfig.map.get(room.teamType);
				// 如果达到房间容纳小队数量上限，则直接发送确认
				if (room.teamCount * room.teamType >= teamTemplate.getCreateRoomCondition()) {
					JobKey jobKey = JobScheduler.generateSendEnterJobKey(room);
					JobScheduler.stopJob(jobKey);
					sendEnter(room, Arrays.asList(accountId));
				}
			}
		}
	}
	
	public void kickHero() {
		String localhost = ZookeeperClient.getInstance().localhost;
		ServerAddress serverAddress = new ServerAddress(localhost);
		kickHero(serverAddress);
	}
	
	public void kickHero(ServerAddress serverAddress) {
		List<Long> heroIdList = Model.getInstance().heroMap.values().stream().map(r -> r.getAccountId()).collect(Collectors.toList());
		MsgHelper.broadcastKick(heroIdList);
		Account account = new Account();
		account.setIp(serverAddress.getIp());
		account.setPort(serverAddress.getPort());
		accountDao.update(account);
	}
}
